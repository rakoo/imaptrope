# $Id$
# Copyright (C) 2005  Shugo Maeda <shugo@ruby-lang.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

class IMAPTrope
  NON_AUTHENTICATED_STATE = :NON_AUTHENTICATED_STATE
  AUTHENTICATED_STATE = :AUTHENTICATED_STATE
  SELECTED_STATE = :SELECTED_STATE
  LOGOUT_STATE = :LOGOUT_STATE

  class Session
    attr_reader :config, :state, :mail_store, :current_mailbox, :peeraddr
    attr_accessor :secure, :idle
    alias secure? secure
    alias idle? idle

    NON_AUTEHNTICATED_MAX_IDLE_SECONDS = 10
    AUTEHNTICATED_MAX_IDLE_SECONDS = 30 * 60

    @@test = false

    def self.test
      return @@test
    end

    def self.test=(test)
      @@test = test
    end

    def initialize(config, sock, mail_store, imapd, pre_authenticated = false)
      @config = config
      @sock = sock
      @mail_store = mail_store
      @imapd = imapd
      @pre_authenticated = pre_authenticated
      @logger = @config[:logger]
      @parser = CommandParser.new(self, @logger)
      @logout = false
      @peeraddr = nil
      if pre_authenticated
        @state = AUTHENTICATED_STATE
        @max_idle_seconds = AUTEHNTICATED_MAX_IDLE_SECONDS
      else
        @state = NON_AUTHENTICATED_STATE
        @max_idle_seconds = NON_AUTEHNTICATED_MAX_IDLE_SECONDS
      end
      @current_mailbox = nil
      @read_only = false
      @secure = @sock.kind_of?(OpenSSL::SSL::SSLSocket)
      @queued_responses = {}
    end

    def starttls
      raise "no capability" unless @config["starttls"]
      raise "available only for non-authenticated-state" if @state != NON_AUTHENTICATED_STATE
      raise "already in TLS" if secure?

      require "openssl"
      synchronize do
        ssl_ctx = OpenSSL::SSL::SSLContext.new
        if @config.key?("ssl_key") && @config.key?("ssl_cert")
          ssl_ctx.key = File.open(File.expand_path(@config["ssl_key"]), 'r') { |f|
            OpenSSL::PKey::RSA.new(f)
          }
          ssl_ctx.cert = File.open(File.expand_path(@config["ssl_cert"]), 'r') { |f|
            OpenSSL::X509::Certificate.new(f)
          }
        else
          require 'webrick/ssl'
          ssl_ctx.cert, ssl_ctx.key =
            WEBrick::Utils::create_self_signed_cert(1024, [["CN", "Ximapd"]],
                                                    "Generated by Ruby/OpenSSL")
        end
        @sock = OpenSSL::SSL::SSLSocket.new(@sock, ssl_ctx)
        @secure = true
      end
    end

    def starttls_accept
      @sock.accept
    end

    def start
      synchronize do
        @peeraddr = @sock.peeraddr[3]
        @logger.info("connect from #{@peeraddr}")
        if @pre_authenticated
          send_preauth("ximapd version %s", VERSION)
        else
          send_ok("ximapd version %s", VERSION)
        end
      end
      begin
        while !@logout
          begin
            cmd = recv_cmd
          rescue StandardError => e
            raise if @@test
            send_bad("parse error: %s", e)
            next
          end
          break if cmd.nil?
          @logger.debug("received #{cmd.tag} #{cmd.name} from #{@peeraddr}")
          begin
            if @config["profile"] && cmd.name != "IDLE"
              profile(cmd) do
                cmd.exec
              end
            else
              cmd.exec
            end
          rescue Errno::EPIPE => e
            @logger.log_exception(e)
            break
          rescue StandardError => e
            raise if @@test
            send_tagged_no(cmd.tag, "%s failed - %s", cmd.name, e)
            @logger.log_exception(e)
          end
          @logger.debug("processed #{cmd.tag} #{cmd.name} from #{@peeraddr}")
        end
      rescue Timeout::Error
        @logger.info("autologout #{@peeraddr}")
        send_data("BYE Autologout; idle for too long")
      rescue TerminateException
        send_data("BYE IMAP server terminating connection")
      end
      synchronize do
        sync
        @sock.close
        @logger.info("disconnect from #{@peeraddr}")
      end
    end

    def logout
      @state = LOGOUT_STATE
      @logout = true
    end

    def login
      @state = AUTHENTICATED_STATE
      @max_idle_seconds = AUTEHNTICATED_MAX_IDLE_SECONDS
    end

    def select(mailbox)
      @current_mailbox = mailbox
      @read_only = false
      @state = SELECTED_STATE
    end

    def examine(mailbox)
      @current_mailbox = mailbox
      @read_only = true
      @state = SELECTED_STATE
    end

    def get_current_mailbox
			return @mail_store.get_mailbox(@current_mailbox)
    end

    def read_only?
      return @read_only
    end

    def close_mailbox
      cleanup_queued_responses
      @current_mailbox = nil
      @state = AUTHENTICATED_STATE
    end

    def sync
      @mail_store.write_last_peeked_uids
    end

    def push_response(mailbox, response)
      if mailbox.nil? || @current_mailbox == mailbox
        @queued_responses[mailbox] ||= []
        @queued_responses[mailbox].push "* " + response
      else
        # noop
      end
    end

    def recv_line
      timeout(@max_idle_seconds) do
        s = @sock.gets
        return s if s.nil?
        line = s.sub(/\r\n\z/n, "")
        @logger.debug(line.gsub(/^/n, "C: ")) if @config["debug"]
        return line
      end
    end

    def recv_cmd
      timeout(@max_idle_seconds) do
        buf = ""
        loop do
          s = @sock.gets
          break unless s
          s.gsub!(/\r?\n\z/, "\r\n")
          buf.concat(s)
          if len = s.slice(/\{(\d+)\}\r\n/n, 1)
            send_continue_req("Ready for additional command text")
            n = len.to_i
            while n > 0
              tmp = @sock.read(n)
              n -= tmp.length
              buf.concat(tmp)
            end
          else
            break
          end
        end
        return nil if buf.length == 0
        @logger.debug(buf.gsub(/^/n, "C: ")) if @config[:debug]
        return @parser.parse(buf)
      end
    end

    def send_line(line)
      @logger.debug(line.gsub(/^/, "S: ")) if @config[:debug]
      @sock.print(line + "\r\n")
    end

    def send_tagged_response(tag, name, fmt, *args)
      msg = format(fmt, *args)
      send_line(tag + " " + name + " " + msg)
    end

    def send_tagged_ok(tag, fmt, *args)
      send_tagged_response(tag, "OK", fmt, *args)
    end

    def send_tagged_no(tag, fmt, *args)
      send_tagged_response(tag, "NO", fmt, *args)
    end

    def send_tagged_bad(tag, fmt, *args)
      send_tagged_response(tag, "BAD", fmt, *args)
    end

    def send_queued_responses(exclude = nil)
      synchronize do
        queued_responses = []
        if @queued_responses.include?(@current_mailbox) &&
            !@queued_responses[@current_mailbox].empty?
          queued_responses << @queued_responses[@current_mailbox]
        end
        if @current_mailbox &&
            @queued_responses.include?(nil) &&
            !@queued_responses[nil].empty?
          queued_responses << @queued_responses[@current_mailbox]
        end
        queued_responses.each do |qr|
          if exclude
            rest, done = qr.partition do |str|
              exclude =~ str
            end
          else
            rest, done = [], qr
          end
          done.reverse.each do |str|
            send_line str
          end
          qr.replace(rest)
        end
        cleanup_queued_responses
      end
    end

    def send_data(fmt, *args)
      s = format(fmt, *args)
      send_line("* " + s)
    end

    def send_ok(fmt, *args)
      send_data("OK " + fmt, *args)
    end

    def send_no(fmt, *args)
      send_data("NO " + fmt, *args)
    end

    def send_bad(fmt, *args)
      send_data("BAD " + fmt, *args)
    end

    def send_preauth(fmt, *args)
      send_data("PREAUTH " + fmt, *args)
    end

    def send_continue_req(fmt, *args)
      msg = format(fmt, *args)
      send_line("+ " + msg)
    end

    def synchronize(&block)
      @mail_store.synchronize(&block)
    end

    def all_session_on_idle?
      @imapd.all_session_on_idle?
    end

    def push_queued_response(mailbox_name, resp)
      return if @@test && @imapd.nil?
      @imapd.push_response(mailbox_name, resp, self)
    end

    private

    def cleanup_queued_responses
      synchronize do
        @queued_responses.delete_if do |mailbox, queued_response|
          mailbox.nil? ?  false : true
        end
      end
    end

    def profile(cmd)
      begin
        Prof.start
      rescue
        return yield
      end
      begin
        yield
      ensure
        result = Prof.stop
        total = result.detect { |i|
          i.method_class.nil? && i.method_id == :"#toplevel"
        }.total_time
        if total == 0.0
          total = 0.001
        end
        sum = 0
        path = File.expand_path("profile.log", @config[:data_dir])
        File.open(path, "a") do |f|
          f.printf(">>> %s %s\n", cmd.tag, cmd.name)
          f.print("  %%   cumulative   self              self     total\n")
          f.print(" time   seconds   seconds    calls  ms/call  ms/call  name\n")
          for r in result
            sum += r.self_time
            if r.method_class.nil?
              name = r.method_id.to_s
            elsif r.method_class.is_a?(Class)
              name = r.method_class.to_s + "#" + r.method_id.to_s
            else
              name = r.method_class.to_s + "." + r.method_id.to_s
            end
            f.printf("%6.2f %8.3f  %8.3f %8d %8.2f %8.2f  %s\n",
                     r.self_time / total * 100, sum, r.self_time, r.count,
                     r.self_time * 1000 / r.count, r.total_time * 1000 / r.count,
                     name)
          end
        end
      end
    end
  end
end
